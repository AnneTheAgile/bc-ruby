zRspec.BestPractices.txt
[]cf bookmarks sw-tips
 let(:user) { User.locate }
[]Use factory_girl to reduce the verbosity when working with models.
# after
user = Factory.create(:user)
# before
user = User.create( :name => "Genoveffa",
                    :surname => "Piccolina",
                    :city => "Billyville",
                    :birth => "17 Agoust 1982",
                    :active => true)
[]Start context with ‘when’/'with’ and methods description with ‘#’
    context "when user is a M" do
      before { @user.gender = 'M' }
 
      it { should be_an IMac }
    end
[]Test Valid, Edge and Invalid cases Boundary value analysis, context "when valid" do


==========================================================
52.[]Red/Green pics ; X.Better Specs { rspec guidelines with ruby }
http://betterspecs.org/
Better Specs { rspec guidelines with ruby }
...

Use subject
If you have several tests related to the same subject use subject{} to DRY them up.
bad
it { expect(assigns('message')).to match /it was born in Belville/ }
it { expect(assigns('message').creator).to match /Topolino/ }

good
subject { assigns('message') }
it { should match /it was born in Billville/ }

RSpec has also the ability to use a named subject.

Good

subject(:hero) { Hero.first }
it "carries a sword" do
  expect(hero.equipment).to include "sword"
end
https://www.relishapp.com/rspec/rspec-core/v/2-11/docs/subject
Learn more about rspec subject.

Use let and let!

When you have to assign a variable instead of using a before block to create an instance variable, use let. Using let the variable lazy loads only when it is used the first time in the test and get cached until that specific test is finished. A really good and deep description of what let can be found in this stackoverflow answer.
...
good

describe '#type_id' do
  let(:resource) { FactoryGirl.create :device }
  let(:type)     { Type.find resource.type_id }

  it 'sets the type_id field' do
    expect(resource.type_id).to equal(type.id)
  end
end

Use let to initialize actions that are lazy loaded to test your specs.

good
context 'when updates a not existing property value' do
  let(:properties) { { id: Settings.resource_id, value: 'on'} }

  def update
    resource.properties = properties
  end

  it 'raises a not found error' do
    expect { update }.to raise_error Mongoid::Errors::DocumentNotFound
  end
end

Use let! if you want to define the variable when the block is defined. This can be useful to populate your database to test queries or scopes.

Here an example of what let actually is.

good
# this:
let(:foo) { Foo.new }

# is very nearly equivalent to this:
def foo
  @foo ||= Foo.new
end
https://www.relishapp.com/rspec/rspec-core/v/2-11/docs/helper-methods/let-and-let
Learn more about rspec let. 

Use factories and not fixtures
good
unit tests the best practice would be to use neither fixtures or factories.
user = FactoryGirl.create :user
https://github.com/thoughtbot/factory_girl
http://blog.steveklabnik.com/posts/2012-07-14-why-i-don-t-like-factory_girl

In our experience, shared examples are used mainly for controllers. Since models are pretty different from each other, they (usually) do not share much logic. 
good
https://www.relishapp.com/rspec/rspec-core/v/2-11/docs/example-groups/shared-examples
describe 'GET /devices' do

  let!(:resource) { FactoryGirl.create :device, created_from: user.id }
  let(:uri)       { '/devices' }

  it_behaves_like 'a listable resource'
  it_behaves_like 'a paginable resource'
  it_behaves_like 'a searchable resource'
  it_behaves_like 'a filterable list'
end

Stubbing HTTP requests
  let(:uri) { 'http://api.lelylan.com/types' }
  before    { stub_request(:get, uri).to_return(status: 401, body: fixture('401.json')) }

==========================================================
1.[]Test API of a thing, adheres to interface aka Shared Examples so X should be Y-able ; X.shared examples - Example groups - RSpec Core - RSpec - Relish
https://www.relishapp.com/rspec/rspec-core/v/2-11/docs/example-groups/shared-examples
shared examples - Example groups - RSpec Core - RSpec - Relish

Shared examples let you describe behaviour of types or modules. When
declared, a shared group's content is stored. It is only realized in the
context of another example group, which provides any context the shared group
needs to run.

A shared group is included in another group using any of:

include_examples "name"      # include the examples in the current context
it_behaves_like "name"       # include the examples in a nested context
it_should_behave_like "name" # include the examples in a nested context

WARNING: Files containing shared groups must be loaded before the files that
use them. While there are conventions to handle this, RSpec does not do
anything special (like autoload). Doing so would require a strict naming
convention for files that would break existing suites.

CONVENTIONS:

    The simplest approach is to require files with shared examples explicitly
    from the files that use them. Keep in mind that RSpec adds the spec directory to the LOAD_PATH, so you can say require 'shared_examples_for_widgets' to require a file at #{PROJECT_ROOT}/spec/shared_examples_for_widgets.rb.

    Put files containing shared examples in spec/support/ and require files
    in that directory from spec/spec_helper.rb:

    Dir["./spec/support/**/*.rb"].each {|f| require f}

    This is included in the generated spec/spec_helper.rb file in rspec-rails

    When all of the groups that include the shared group, just declare
    the shared group in the same file.

Scenarios

        shared examples group included in two groups in one file
        Providing context to a shared group using a block
        Passing parameters to a shared example group
        Aliasing "it_should_behave_like" to "it_has_behavior"

    shared examples group included in two groups in one file

        Given
            a file named "collection_spec.rb" with:

            require "set"

            shared_examples "a collection" do
              let(:collection) { described_class.new([7, 2, 4]) }

              context "initialized with 3 items" do
                it "says it has three items" do
                  collection.size.should eq(3)
                end
              end

              describe "#include?" do
                context "with an an item that is in the collection" do
                  it "returns true" do
                    collection.include?(7).should be_true
                  end
                end

                context "with an an item that is not in the collection" do
                  it "returns false" do
                    collection.include?(9).should be_false
                  end
                end
              end
            end

            describe Array do
              it_behaves_like "a collection"
            end

            describe Set do
              it_behaves_like "a collection"
            end

        When
            I run rspec collection_spec.rb --format documentation 
        Then
            the examples should all pass 
        And
            the output should contain:

            Array
              behaves like a collection
                initialized with 3 items
                  says it has three items
                #include?
                  with an an item that is in the collection
                    returns true
                  with an an item that is not in the collection
                    returns false

            Set
              behaves like a collection
                initialized with 3 items
                  says it has three items
                #include?
                  with an an item that is in the collection
                    returns true
                  with an an item that is not in the collection
                    returns false

    Providing context to a shared group using a block

        Given
            a file named "shared_example_group_spec.rb" with:

            require "set"

            shared_examples "a collection object" do
              describe "<<" do
                it "adds objects to the end of the collection" do
                  collection << 1
                  collection << 2
                  collection.to_a.should eq([1,2])
                end
              end
            end

            describe Array do
              it_behaves_like "a collection object" do
                let(:collection) { Array.new }
              end
            end

            describe Set do
              it_behaves_like "a collection object" do
                let(:collection) { Set.new }
              end
            end

        When
            I run rspec shared_example_group_spec.rb --format documentation 
        Then
            the examples should all pass 
        And
            the output should contain:

            Array
              behaves like a collection object
                <<
                  adds objects to the end of the collection

            Set
              behaves like a collection object
                <<
                  adds objects to the end of the collection

    Passing parameters to a shared example group

        Given
            a file named "shared_example_group_params_spec.rb" with:

            shared_examples "a measurable object" do |measurement, measurement_methods|
              measurement_methods.each do |measurement_method|
                it "should return #{measurement} from ##{measurement_method}" do
                  subject.send(measurement_method).should == measurement
                end
              end
            end

            describe Array, "with 3 items" do
              subject { [1, 2, 3] }
              it_should_behave_like "a measurable object", 3, [:size, :length]
            end

            describe String, "of 6 characters" do
              subject { "FooBar" }
              it_should_behave_like "a measurable object", 6, [:size, :length]
            end

        When
            I run rspec shared_example_group_params_spec.rb --format documentation 
        Then
            the examples should all pass 
        And
            the output should contain:

            Array with 3 items
              it should behave like a measurable object
                should return 3 from #size
                should return 3 from #length

            String of 6 characters
              it should behave like a measurable object
                should return 6 from #size
                should return 6 from #length

    Aliasing "it_should_behave_like" to "it_has_behavior"

        Given
            a file named "shared_example_group_spec.rb" with:

            RSpec.configure do |c|
              c.alias_it_should_behave_like_to :it_has_behavior, 'has behavior:'
            end

            shared_examples 'sortability' do
              it 'responds to <=>' do
                sortable.should respond_to(:<=>)
              end
            end

            describe String do
              it_has_behavior 'sortability' do
                let(:sortable) { 'sample string' }
              end
            end

        When
            I run rspec shared_example_group_spec.rb --format documentation 
        Then
            the examples should all pass 
        And
            the output should contain:

            String
              has behavior: sortability
                responds to <=>


==========================================================
57.[] ; X.My top 7 RSpec best practices; 1.before :all block. But be careful — these blocks are not wrapped in a transaction, so the data will not be rolled back; 2.For each test create exactly what it needs simplify test data creation, I personally recommend factory_girl: ; 3.Do not create hundreds of records for a particular spec add a parameter to the method, which will limit the number of records to return. ; 4. Do not over-mock use integration approach: controller should talk to models, which have to hit the database. Real database with real data (OK, not so real).; 5.Use Contexts describe, describe Video do context 'when just created' do;before :each do; 6. Create several test suites to speed up your workflow  several standard test suites configured in RSpec by default: spec:controllers, spec:views, spec:helpers, spec:lib. 7. Stop spec_helper from being loaded multiple times , so ADD Debugger code,show where you’ve tried to load spec_helper from so you will be able to fix it immediately.  X. | Dmytro Shteflyuk's Home
http://kpumuk.info/ruby-on-rails/my-top-7-rspec-best-practices/
My top 7 RSpec best practices | Dmytro Shteflyuk's Home

My top 7 RSpec best practices

Posted by Dmytro Shteflyuk on November 25, 2009 under Ruby & Rails (148,873 views)
BDD kinkier than TDD

I use RSpec in all my projects. It’s really hard to overemphasize how helpful it is and how much easier becomes your life if you have good specs coverage. But its outstanding flexibility enables many ways to make your specs awful: horribly slow, over-bloated, even non-readable sometimes. I do not want to teach you BDD and RSpec here, but instead I will give you some ideas how to improve your specs quality and increase efficiency of your BDD workflow.

1. Use before :all block carefully

Sometimes it looks like a good idea to create a test data in before :all block. But be careful — these blocks are not wrapped in a transaction, so the data will not be rolled back after the test. In this case you should clear your data in the after :all block manually.
1
2
3
4
5
6
7
8
9
10
11
12
13
	
describe Friendship do
  before :all do
    @users = (1..5).collect { Factory(:user) }
  end

  after :all do
    @users.each { |user| user.destroy! }
  end

  it 'should do something' do
    # Something interesting with @users
  end
end

Another option is to move your before :all blocks to before :each to make them rolled back automatically.
2. For each test create exactly what it needs

Fixtures are cool when you start working on a project. But they quickly become painful while project grows: you add a new field to a fixture and break a half of your tests. There are tons of plugins which could simplify test data creation, I personally recommend factory_girl: it’s pretty slick and easy to use.
1
2
3
4
5
6
7
8
	
Factory.define :user do |f|
  f.sequence(:login) { |n| "user#{n}" }
  f.email { |a| "#{a.login}@example.com" }
  f.description "Ruby on Rails Developer"
end

# Somewhere in specs
@user = Factory(:user, :admin => true)
3. Do not create hundreds of records for a particular spec

Sometimes you want to test a method which operates on large set of records (filtering, trimming, etc). For example, this method returns 50 most popular videos (and no more). The straight approach is to create 51 record and make sure, that the size of the returned array is 50. When I saw a code snippet like this in our project first time, I was surprised. There was a few more pieces sharing this behavior, so here is my advice: add a parameter to the method, which will limit the number of records to return. In this case you can create 3 records, and pass 2 as a parameter.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
	
describe User do
  it 'should return top users in User.top method' do
    @users = (1..3).collect { Factory(:user) }
    top_users = User.top(2).all
    top_users.should have(2).entries
  end
end

class User < ActiveRecord::Base
  # Select N top users. Returns 10 entries when called without arguments.
  #   User.top.all.size    # => 10
  #   User.top(2).all.size # => 2
  #
  named_scope :top, lambda { |*args| { :limit => (args.size > 0 ? args[0] : 10) } }
end
4. Do not over-mock

Mocking is interesting and sometimes very useful technology. You may mock just everything so you spec will not hit the database. But there is a catch: your model code may be changed some day causing callers to break. Since you mock everything, you will never get failing specs. So now you should update all your mocks to fit a new interface. Also you would not be able to find SQL queries errors if you have mocked them. Instead of this I use integration approach: controller should talk to models, which have to hit the database. Real database with real data (OK, not so real). The practice 2 can help you in test data creation.

Bad:
1
2
3
4
5
6
7
8
9
10
11
12
	
describe VideosController do
  describe '.create action' do
    it 'should assign top videos' do
      params = { :title => 'new video', :description => 'video description' }
      @video = mock_model(Video)
      Video.should_receive(:new).and_return(@video)
      @video.should_receive(:update_attributes).with(params).and_return(true)
      get :index, :video => params
      assigns[:video].should be(@video)
    end
  end
end

Good:
1
2
3
4
5
6
7
8
9
10
11
	
describe VideosController do
  describe '.create action' do
    it 'should assign top videos' do
      params = { :title => 'new video', :description => 'video description' }
      get :index, :video => params
      assigns[:video].should_not be_new_record
      assigns[:video].title.should == params[:title]
      assigns[:video].description.should == params[:description]
    end
  end
end

But you can use mocks to skip records retrieving from the database (make sure you have specs covering corresponding model code). Let me explain this. For example, you need to render 20 entries in an RSS feed. You could create 21 record in the database using a factory, and then ensure only 20 of them were retrieved, or you could mock your finder method and check its parameter. You may not like magic numbers like 20 in this particular case, and this is a good point. Just move this magic number to the config and ensure it was used to do the retrieval.
1
2
3
4
5
6
7
8
9
10
	
describe VideosController do
  describe '.index action' do
    it 'should assign top videos' do
      @videos = [mock_model(Video), mock_model(Video)]
      Video.should_receive(:top).with(50).and_return(@videos)
      get :index
      assigns[:top_videos].should be(@videos)
    end
  end
end
5. Use contexts

RSpec spec specifies how particular code should work. Usually, in the beginning you tell what you are going to describe in this spec, and inside describe block you specify what the code should do:
1
2
3
4
5
	
describe Video do
  it 'should return 5 records in Video.top method' do
    Video.top.should have(5).items
  end
end

Usually you have more than one it block for each method. To group related specs I recommend to use nested describe blocks. Since describe is aliased to context when placed inside another describe, I think it’s a good idea to use it for specs grouping. Each context may have its own before and after blocks (in this case parent blocks will be called right before child ones).
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
	
describe Video do
  describe '.top' do
    it 'should return 5 records' do
      Video.top.should have(5).items
    end
  end

  context 'when just created' do
    before :each do
      @video = Video.new
    end
   
    # ...
  end
end
6. Create several test suites to speed up your workflow

There are many things you can do to make your BDD more efficient. We will take a look at two of them: creating a separate test suites and running recently modified specs.

There are several standard test suites configured in RSpec by default: spec:controllers, spec:views, spec:helpers, spec:lib. Check the rake -T spec output to get a list of available RSpec tasks. Let’s create a simple Rake tasks generator for spec suites:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
	
SPEC_SUITES = [
  { :id => :acl, :title => 'access control', :files => %w(spec/controllers/**/acl_spec.rb) },
  { :id => :amazon, :title => 'Amazon libraries', :dirs => %w(spec/lib/amazon) }
]

namespace :spec do
  namespace :suite do
    SPEC_SUITES.each do |suite|
      desc "Run all specs in #{suite[:title]} spec suite"
      Spec::Rake::SpecTask.new(suite[:id]) do |t|
        spec_files = []
        if suite[:files]
          suite[:files].each { |glob| spec_files += Dir[glob] }
        end

        if suite[:dirs]
          suite[:dirs].each { |glob| spec_files += Dir["#{glob}/**/*_spec.rb"] }
        end

        t.spec_opts = ['--options', "\"#{Rails.root}/spec/spec.opts\""]
        t.spec_files = spec_files
      end
    end
  end
end

Check what tasks are available now:
1
2
3
4
5
	
~/test$ rake -T spec:suite

(in /Users/kpumuk/test)
rake spec:suite:acl     # Run all specs in access control spec suite
rake spec:suite:amazon  # Run all specs in Amazon libraries spec suite

It was easy! And now let’s take a look at the Rake task for running the recently touched specs (last 10 minutes).
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
	
# Grab recently touched specs
def recent_specs(touched_since)
  recent_specs = Dir['app/**/*'].map do |path|
    if File.mtime(path) > touched_since
      spec = File.join('spec', File.dirname(path).split("/")[1..-1].join('/'),
      "#{File.basename(path, ".*")}_spec.rb")
      spec if File.exists?(spec)
    end
  end.compact

  recent_specs += Dir['spec/**/*_spec.rb'].select do |path|
    File.mtime(path) > touched_since
  end.uniq
end

namespace :spec do
  desc 'Run all recent specs in spec directory touched in last 10 minutes'
  Spec::Rake::SpecTask.new(:recent) do |t|
    t.spec_opts = ['--options', "\"#{RAILS_ROOT}/spec/spec.opts\""]
    t.spec_files = recent_specs(Time.now - 10.minutes)
  end
end

And don’t forget to check autospec and watchr gems.
7. Stop spec_helper from being loaded multiple times

Just don’t do that. If you got a big project, there is a chance that the spec_helper will be required in a many different ways: File.expand_path, File.join, etc.,— which results in it being loaded several times and it slows down your test suite!

To avoid this, add the following code at the top of your spec_helper.rb:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
	
# figure out where we are being loaded from
if $LOADED_FEATURES.grep(/spec\/spec_helper\.rb/).any?
  begin
    raise "foo"
  rescue => e
    puts <<-MSG
  ===================================================
  It looks like spec_helper.rb has been loaded
  multiple times. Normalize the require to:

    require "spec/spec_helper"

  Things like File.join and File.expand_path will
  cause it to be loaded multiple times.

  Loaded this time from:

    #{e.backtrace.join("\n    ")}
  ===================================================
    MSG
  end
end

It will show where you’ve tried to load spec_helper from so you will be able to fix it immediately. Also there is an interesting snippet of code here, which will find and replace all wrong includes.
Conclusion

RSpec is not a silver bullet. You can have 100% coverage and fine-grained specs, but it does not mean your application is completely bug-free. Refactor your specs, increase your programming level, and refactor again. Write specs for any issue that you, your QAs or users have faced. And remember: do not over-mock.
Credits

This is my first article written completely in Google Wave in collaboration with several good Russian rubyists. Thank you all, guys. I want to acknowledge the editorial help of Roman Dmytrenko and Alexey Kovyrin. Robby Russell created a great picture illustrating how sexy is RSpec. And thank you all my readers for your attention.

Did you like this article? You should follow me in Twitter here.
==========================================================
54.[] ; X.abinoda/rspec-best-practices
https://github.com/abinoda/rspec-best-practices
abinoda/rspec-best-practices
Rspec Best Practices

A collection of Rspec testing best practices
Table of Contents

    Describe your methods
    Use Context
    Only one expectation per example
    Test valid, edge and invalid cases
    Use let
    DRY
    Optimize database queries
    Use factories
    Choose matchers based on readability
    Run specific tests
    Debug Capybara tests with save_and_open_page
    Only enable JS in Capybara when necessary
    Consult the logs
    Other tips
    More Resources
    Libraries

Describe your methods

Keep clear the methods you are describing using "." as prefix for class methods and "#" as prefix for instance methods.

# wrong
describe "the authenticate method for User" do
describe "the save method for User" do

# correct
describe ".authenticate" do
describe "#save" do

Use context

Use context to organize and DRY up code, keep spec descriptions short, and improve test readability.

# wrong
describe User do
  it "should save when name is not empty" do
    User.new(:name => 'Alex').save.should == true
  end

  it "should not save when name is empty" do
    User.new.save.should == false
  end

  it "should not be valid when name is empty" do
    User.new.should_not be_valid
  end

  it "should be valid when name is not empty" do
    User.new(:name => 'Alex').should be_valid
  end
end

# correct
describe User do
  let (:user) { User.new }

  context "when name is empty" do
    it "should not be valid" do
      expect(user.valid?).to be_false
    end

    it "should not save" do
      expect(user.save).to be_false
    end
  end

  context "when name is not empty" do
    let (:user) { User.new(:name => "Alex") }

    it "should be valid" do
      expect(user.valid?).to be_true
    end

    it "should save" do
      expect(user.save).to be_true
    end
  end
end

Only one expectation per example

Each test example should make only one assertion. This helps you on find errors faster and makes your code easier to read and maintain.

# wrong
describe "#fill_gass" do
  it "should have valid arguments" do
    expect { car.fill_gas }.to raise_error(ArgumentError)
    expect { car.fill_gas("foo") }.to_raise_error(TypeError)
  end
end

# correct
describe "#fill_gass" do
  it "should require one argument" do
    expect { car.fill_gas }.to raise_error(ArgumentError)
  end

  it "should require a numeric argument" do
    expect { car.fill_gas("foo") }.to_raise_error(TypeError)
  end
end

Test valid, edge and invalid cases

This is called Boundary value analysis, it’s simple and it will help you to cover the most important cases. Just split-up method’s input or object’s attributes into valid and invalid partitions and test both of them and there boundaries. A method specification might look like that:

describe "#month_in_english(month_id)" do
  context "when valid" do
    it "should return 'January' for 1" # lower boundary
    it "should return 'March' for 3"
    it "should return 'December' for 12" # upper boundary
  context "when invalid" do
    it "should return nil for 0"
    it "should return nil for 13"
  end
end

Use let

When you have to assign a variable to test, instead of using a before each block, use let. It is memoized when used multiple times in one example, but not across examples.

# wrong
describe User, '#locate'
  before(:each) { @user = User.locate }

  it 'should return nil when not found' do
    @user.should be_nil
  end
end

# correct
describe User
  let(:user) { User.locate }

  it 'should have a name' do
    user.name.should_not be_nil
  end
end

DRY

Be sure to apply good code refactoring principles to your tests.

Use before and after hooks:

describe Thing do
  before(:each) do
    @thing = Thing.new
  end

  describe "initialized in before(:each)" do
    it "has 0 widgets" do
      @thing.should have(0).widgets
    end

    it "does not share state across examples" do
      @thing.should have(0).widgets
    end
  end
end

Extract reusable code into helper methods:

# spec/fetures/user_signs_in_spec.rb
require 'spec_helper'

feature 'User can sign in' do
  scenario 'as a user' do
    sign_in

    expect(page).to have_content "Your account"
  end
end

# spec/fetures/user_signs_out_spec.rb
require 'spec_helper'

feature 'User can sign out' do
  scenario 'as a user' do
    sign_in

    click_link "Logout"

    expect(page).to have_content "Sign up"
  end
end

# spec/support/authentication_helper.rb
module AuthenticationHelper
  def sign_in
    visit root_path

    user = FactoryGirl.create(:user)

    fill_in 'user_session_email',    with: user.email
    fill_in 'user_session_password', with: user.password
    click_button "Sign in"

    return user
  end
end

# spec/spec_helper.rb
RSpec.configure do |config|
  config.include AuthenticationHelper, type: :feature
  # ...

Optimize database queries

Large test suites can take a long time to run. Don't load or create more data than necessary.

describe User do
  it 'should return top users in User.top method' do
    @users = (1..3).collect { Factory(:user) }
    top_users = User.top(2).all
    top_users.should have(2).entries
  end
end

class User < ActiveRecord::Base
  named_scope :top, lambda { |*args| { :limit => (args.size > 0 ? args[0] : 10) } }
end

Use factories

Use factory_girl to reduce the verbosity when working with models.

# before
user = User.create( :name => "Genoveffa",
                    :surname => "Piccolina",
                    :city => "Billyville",
                    :birth => "17 Agoust 1982",
                    :active => true)

# after
user = Factory.create(:user)

Choose matchers based on readability

RSpec comes with a lot of useful matchers to help your specs read more like language. When you feel there is a cleaner way … there usually is!

Here are some examples, before and after they are applied:

# before: double negative
object.should_not be_nil
# after: without the double negative
object.should be

# before: 'lambda' is too low level
lambda { model.save! }.should raise_error(ActiveRecord::RecordNotFound)
# after: for a more natural expectation replace 'lambda' and 'should' with 'expect' and 'to'
expect { model.save! }.to raise_error(ActiveRecord::RecordNotFound)

# before: straight comparison
collection.size.should == 4
# after: a higher level size expectation
collection.should have(4).items

Run specific tests

Running your entire test suite over and over again is a waste of time.

Run example or block at specified line:

# in rails
rake spec SPEC=spec/models/demand_spec.rb:30

# not in rails
rspec spec/models/demand_spec.rb:30

Run examples that match a given string:

# in rails
rake spec SPEC=spec/controllers/sessions_controller_spec.rb \
          SPEC_OPTS="-e \"should log in with cookie\""

# not in rails
rspec spec/login_spec.rb -e "should log in with cookie"

In Rails, run only your integration tests:

rake spec:features

Debug Capybara tests with save_and_open_page

Capybara has a save_and_open_page method. As the name implies, it saves the page — complete with styling and images — and opens it in your browser so you can inspect it:

it 'should register successfully' do
  visit registration_page
  save_and_open_page
  fill_in 'username', :with => 'abinoda'
end

Only enable JS in Capybara when necessary

Only enable JS when your tests require it. Enabling JS slows down your test suite.

# only use js => true when your tests depend on it
it 'should register successfully', :js => true do
  visit registration_page
  fill_in 'username', :with => 'abinoda'
end

Unless the pages you are testing require JS, it's best to disable JS after you're done writing the test so that the test suite runs faster.
Consult the logs

When you run any rails application (the webserver, tests or rake tasks), ouput is saved to a log file. There is a log file for each environment: log/development.log, log/test.log, etc.

Take a moment to open up one of these log files in your editor and take a look at its contents. To watch your test log files, use the *nix tool tail:

tail -f log/test.log

Curious what -f means? Check the man page for the tail utility: man tail
Other tips

    When something in your application goes wrong, write a test that reproduces the error and then correct it. You will gain several hour of sleep and more serenity.
    Use solutions like guard (using guard-rspec) to automatically run all of your test, without thinking about it. Combining it with growl, it will become one of your best friends. Examples of other solutions are test_notifier, watchr and autotest.
    Use TimeCop to mock and test methods that relies on time.
    Use Webmock to mock HTTP calls to remote service that could not be available all the time and that you want to personalize.
    Use a good looking formatter to check if your test passed or failed. I use fuubar, which to me looks perfect.

More Resources

    Why Our Code Smells
    Request Specs and Capybara
    How I Test
    Dmytro best practices
    Great Rails/Rspec example code

Libraries

    RSpec
    Factory girl
    Shoulda Matchers
    Capybara
    Database Cleaner
    Spork
    Timecop
    Guard
    Fuubar
    Webmock
==========================================================
53.[] ; X.(My) RSpec best practices and tips | EggsOnBread
http://eggsonbread.com/2010/03/28/my-rspec-best-practices-and-tips/
(My) RSpec best practices and tips | EggsOnBread
(My) RSpec best practices and tips
March 28, 2010

After a year using RSpec, I’m happy to share “(My) RSpec Best Practices and Tips”. Let’s make your specs easier to maintain, less verbose, more structured and covering more cases!
Use shortcuts specify {}, it {} and subject {}

You think RSpec is verbose? In case your code doesn’t need any description, use a specify block!
it "should be valid" do
  @user.should be_valid
end

can be replaced with
specify { @user.should be_valid }

RSpec will generate a nice description text for you when running this expectation. Even better, you can use the it block!
describe User do
  it { should validate_presence_of :name }
  it { should have_one :address }
end

In case the subject is the not the class described, just set it with the subject method:
subject { @user.address }
it { should be_valid }
Start context with ‘when’/'with’ and methods description with ‘#’

Have you ever get a failed test with an incomprehensible error message like:
User non confirmed confirm email wrong token should not be valid

Start your contexts with when and get nice messages like:
User when non confirmed when #confirm_email with wrong token should not be valid
Use RSpec matchers to get meaningful messages

In case of failure
specify { user.valid?.should == true }

displays:
'User should == true' FAILED
  expected: true,
  got: false (using ==)

While
specify { user.should be_valid }

displays:
'User should be valid' FAILED
  expected valid? to return true, got false

Nice eh?
Only one expectation per it block

I often see specs where it blocks contain several expectations. This makes your tests harder to read and maintain.

So instead of that…
describe DemoMan do
  it "should have expected attributes" do
    demo_man = DemoMan.new
    demo_man.should respond_to :name
    demo_man.should respond_to :gender
    demo_man.should respond_to :age
  end
end

… do this:
describe DemoMan do
  before(:all) do
    @demo_man = DemoMan.new
  end
 
  subject { @demo_man }
 
  it { should respond_to :name   }
  it { should respond_to :gender }
  it { should respond_to :age    }
end
(Over)use describe and context

Big specs can be a joy to play with as long as they are ordered and DRY. Use nested describe and context blocks as much as you can, each level adding its own specificity in the before block.
To check your specs are well organized, run them in ‘nested’ mode (spec spec/my_spec.rb -cf nested).
Using before(:each) in each context and describe blocks will help you set up the environment without repeating yourself. It also enables you to use it {} blocks.
Bad:
describe User do
 
  it "should save when name is not empty" do
    User.new(:name => 'Alex').save.should == true
  end
 
  it "should not save when name is empty" do
    User.new.save.should == false
  end
 
  it "should not be valid when name is empty" do
    User.new.should_not be_valid
  end
 
  it "should be valid when name is not empty" do
    User.new(:name => 'Alex').should be_valid
  end
 
  it "should give the user a flower when gender is W" do
    User.new(:gender => 'W').present.should be_a Flower
  end
 
  it "should give the user a iMac when gender is M" do
    User.new(:gender => 'M').present.should be_an IMac
  end
end
Good:
describe User do
  before { @user = User.new }
 
  subject { @user }
 
  context "when name empty" do
    it { should not be_valid }
    specify { @user.save.should == false }
  end
 
  context "when name not empty" do
    before { @user.name = 'Sam' }
 
    it { should be_valid }
    specify { @user.save.should == true }
  end
 
  describe :present do
    subject { @user.present }
 
    context "when user is a W" do
      before { @user.gender = 'W' }
 
      it { should be_a Flower }
    end
 
    context "when user is a M" do
      before { @user.gender = 'M' }
 
      it { should be_an IMac }
    end
  end
end
Test Valid, Edge and Invalid cases

This is called Boundary value analysis, it’s simple and it will help you to cover the most important cases. Just split-up method’s input or object’s attributes into valid and invalid partitions and test both of them and there boundaries. A method specification might look like that:
describe "#month_in_english(month_id)" do
  context "when valid" do
    it "should return 'January' for 1" # lower boundary
    it "should return 'March' for 3"
    it "should return 'December' for 12" # upper boundary
  context "when invalid" do
    it "should return nil for 0"
    it "should return nil for 13"
  end
end

I hope this will help you improve your specs. Let me know if I missed anything! :)

You could also be interested in (My) Cucumber best practices and tips or rspec-set a little gem that helps you speeding up your model specs.
===========================================================
.[]
===========================================================
.[]
===========================================================
.[]LET SYNTAX
==========================================================
50.[]TODO will answer my let bug, asof 140115w; Rspec-TIP: NO INSTANCE VARS , only let's, including in this hierarchy; /describe/[let,subject]/context/[let,it] ; X.ruby on rails - Rspec - Difference between let and before block - Stack Overflow
http://stackoverflow.com/questions/5974360/rspec-difference-between-let-and-before-block
ruby on rails - Rspec - Difference between let and before block - Stack Overflow
registration required.
Rspec - Difference between let and before block
up vote 20 down vote favorite
9
	

What is difference between let and before block in rspec?

And when to use these block?

What will be good approach let or before in below example

let(:user) { User.make !}
let(:account) {user.account.make!}

before(:each) do
 @user = User.make!
 @account = @user.account.make!
end

I studied this stackoverflow post

But Is it good to define let for association stuff like above?
ruby-on-rails unit-testing rspec2
share|improve this question
	
edited May 12 '11 at 8:07

	
asked May 12 '11 at 6:50
kriysna
1,47931124
	
	 
	
Basically, 'let' is used by people who dislike instance variables. As a side note, you should consider using FactoryGirl or a similar tool. –  apneadiving May 12 '11 at 7:26
add comment
4 Answers
active oldest votes
up vote 7 down vote accepted
	

Almost always, I prefer let. The post that you link specifies that let is also faster. However, at times, when many commands have to be executed, I could use before(:each) because its syntax is more clear when many commands are involved.

In your example, I would definitely prefer to use let instead of before(:each). Generally speaking, when just some variable initialization is done, I tend to like using let.
share|improve this answer
	
edited Jan 12 '13 at 20:42
JJD
5,74853275
	
answered May 12 '11 at 9:35
Spyros
11.9k54269
	add comment
up vote 17 down vote
	

People seem to have explained some of the basic ways in which they differ, but left out before(:all) and don't explain exactly why they should be used.

It's my belief that instance variables have no place being used in the vast majority of specs, partly due to the reasons mentioned at the top of this article http://bitfluxx.com/2011/05/23/some-rspec-tips-and-best-practices.html, so I won't mention them as an option here.

let blocks

Code within a let block is only executed when referenced, lazy loading this means that ordering of these blocks is irrelevant. This gives you a large amount of power to cut down on repeated setup through your specs.

One (extremely contrived, and small) example of this is:

let(:person)     { build(:person) }
subject(:result) { Library.calculate_awesome(person, has_moustache) }

context 'with a moustache' do
  let(:has_moustache) { true } 
  its(:is_awesome?)   { should be_true }
end

context 'without a moustache' do
  let(:has_moustache) { false } 
  its(:is_awesome?)   { should be_false }
end

Something to note is that the last let block defined in the current context will be used. This is good for setting a default to be used for the majority of specs, which can be overwritten if needed.

For instance, checking the return value of calculate_awesome if passed a person model with top_hat set to true, but no moustache would be done like:

context 'with no moustache but with a top hat' do
  let(:has_moustache) { false } 
  let(:person)        { build(:person, top_hat: true) }
  its(:is_awesome?)   { should be_true }
end

Another thing to note about let blocks, is they are not to be used if you're searching for something which has been saved to the database (i.e. Library.find_awesome_people(search_criteria)) as they will not be saved to the database unless they have already been referenced. let! or before blocks are what should be used here.

Also, never ever use before to trigger execution of let blocks, this is what let! is made for!

let! blocks

let! blocks are executed in order of execution (much like a before block). The one core difference is that you get an explicit reference to this variable, rather than needing to fall back to instance variables.

As with let blocks, if multiple let! blocks are defined with the same name, the most recently defined is what will be used in execution. The core difference being that let! blocks will be executed multiple times if used like this, whereas the let block will only execute the last time.

before(:each) blocks

before(:each) is the default before block, and can therefore be referenced as before {} rather than specifying the full before(:each) {} each time.

It's my personal preference to use before blocks in a few core situations. I will use before blocks if:

    I'm using mocking, stubbing or doubles
    There is any reasonable sized setup (generally this is a sign your factory traits haven't been setup correctly)
    There's a number of variables which I don't need to reference directly, but are required for setup
    I'm writing functional controller tests in rails, and I want to execute a specific request to test (i.e. before { get :index }). Even though you could use subject for this in a lot of cases, it sometimes feels more explicit if you don't require a reference.

If you find yourself writing large before blocks for your specs, check your factories and make sure you fully understand traits and their flexibility.

before(:all) blocks

These are only ever executed once, before the specs in the current context (and its children). These can be used to great advantage if written correctly, as there are certain situations this can cut down on execution and effort.

One example (which would hardly affect execution time at all) is mocking out an ENV variable for a test, which you should only ever need to do once.

Hope that helps :)
share|improve this answer
	
edited Aug 15 '13 at 22:58

	
answered Mar 26 '13 at 22:01
Jay
1,1701623
	add comment
up vote 9 down vote
	

A big difference that hasn't been mentioned is that variables defined with let don't get instantiated until you call it the first time. So while a before(:each) block would instantiate all of the variables, let let's you define a number of variables you might use across multiple tests, it doesn't automatically instantiate them. Without knowing this, your tests could come back to bite yourself if you're expecting all of the data to be loaded beforehand. In some cases, you may even want to define a number of let variables, then use a before(:each) block to call each let instance just to make sure the data is available to begin with.
share|improve this answer
	
answered Jan 9 '12 at 16:35
mikeweber
249137
	
11 	 
	
You can use let! to define methods that are called before each example. See RSpec docs. –  Jim Stewart Aug 3 '12 at 8:55
add comment
up vote 2 down vote
	

It looks like you are using Machinist. Beware, you may see some issues with make! inside of let (the non-bang version) happening outside of the global fixture transaction (if you are using transactional fixtures as well) so corrupting the data for your other tests.
share|improve this answer
	
answered Aug 2 '11 at 21:53
Tim Connor
==========================================================
51.[]Better than shared examples, is but naming differs ; X.Some RSpec Tips and Best Practices - bitfluxx.com
http://bitfluxx.com/2011/05/23/some-rspec-tips-and-best-practices.html
Some RSpec Tips and Best Practices - bitfluxx.com


Some RSpec Tips and Best Practices

Written 23 May 2011

I’ve been working a lot with RSpec lately, in close conjunction with my coworker Myron Marston, who happens to be a committer to RSpec. He’s shown me how a lot of features in RSpec work, how they’re useful and some best practices to use. I thought I’d share some of my favorite ones.
let{}

I used to write specs like this:

describe User, '#locate'
  before(:each) { @user = User.locate }
  
  it 'should return nil when not found' do
    @user.should be_nil
  end
end

Note the use of the @user instance variable for the user. That certainly works, but has the problem of introducing subtle bugs since @instance variables spring into existence as nil when first referenced. This means that if I have a typo in my spec and say @usar.should be_nil, the spec will still pass even if the correctly-named @user variable is not nil. Not good.

Instead, you should use let{}:

    It is memoized when used multiple times in one example, but not across examples.
    It is lazy-loaded, so you won’t waste time initializing the variable for examples that don’t reference it.
    Will raise an exception if you have a typo in your variable name.

So to rewrite the example above using let{}:

describe User
  let(:user) { User.locate }
  
  it 'should have a name' do
    user.name.should_not be_nil
  end
end

There is also a let!{} version (note the added !) that tells RSpec to evaluate the block passed to let before your examples run – basically turning it in to a before(:each) hook. Pretty sweet!
Enhanced it_should_behave_like

Shared example groups were one of those RSpec features that seemed useful in concept, but I found hard to actually use effectively. Mostly I found that it_should_behave_like "some text" wasn’t particularly descriptive enough for all situations, and it was hard for me to craft a generic enough shared example group that I could drop in to an existing example group and have it work well.

Thankfully there are a couple cool features of shared example groups to help with these problems:
Passing context in

it_should_behave_like actually takes a block, which is evaluated before running the shared example group. Thus, you can do this (stolen from RSpec’s cucumber features):

shared_examples "a collection object" do
  describe "<<" do
    it "adds objects to the end of the collection" do
      collection << 1
      collection << 2
      collection.to_a.should eq([1,2])
    end
  end
end

describe Array do
  it_behaves_like "a collection object" do
    let(:collection) { Array.new }
  end
end

describe Set do
  it_behaves_like "a collection object" do
    let(:collection) { Set.new }
  end
end

Passing in arguments

Shared example groups also take parameters to the block. This lets you customize the shared examples as needed based on the values passed in. For example, Myron wrote this cool shared helper:

shared_examples_for "a model that validates presence of" do |property|
  it "requires a value for #{property}" do
    record = new_valid_record
    record.send(:"#{property}=", nil)
    record.should_not be_valid
    record.errors[property.to_sym].should include("can't be blank")
  end
end

Then, to utilize it, you simply call it with the argument passed:

describe User do
  it_behaves_like "a model that validates presence of", :name
end

Aliasing it_should_behave_like

We can do better. To help make your specs read clearer and be more self-documenting, you can alias it_should_behave_like with some simple configuration:

RSpec.configure do |config|
  config.alias_it_should_behave_like_to :it_validates, "it validates"
end

Now, the presence shared example group can be used like this:

describe User do
  it_validates "presence of", :name
end

Much better.
Symbols as Metadata

I certainly didn’t know this before a little while ago, but you can use symbols as metadata in example group definitions:

describe User, :metadata => 'value' do
  it { should be_empty }
end

How do you use this? Well, a bunch of ways.

With the filter_run config option you can tell RSpec what metadata to use to filter specs runs. Basically, only specs with the configured metadata will be run by RSpec. For example:

RSpec.configure do |c|
  c.filter_run :focus => true
end

This will tell RSpec to only run specs with :focus => true metadata. This is very handy when running specs via Guard and focusing your test runs on to a certain spec or specs temporarily.

Conversely, the filter_run_excluding metadata can be used to exclude specs. For example:

RSpec.configure do |c|
  c.filter_run_excluding :broken => true
end

This will tell RSpec to skip specs with the metadata :broken => true.

You can also pass your own custom metadata, that will let you tag specs as needed. For example, you could tag specs with the issue number from your bug tracking software, :issue => 12345.

Then, you can only run those specs for issue #12345 via a command line option:

rspec --tag issue:12345 user_spec.rb

There are lots of other --tag command line options to 
==========================================================
5.[] ; X.Learning Rails part 3 - Using RSpec
http://fizzylogic.nl/learning-rails-part-3-using-rspec/
Learning Rails part 3 - Using RSpec
[]URL CHANGED
http://blogs.infosupport.com/learning-rails-part-3-using-rspec/


Learning Rails part 3 – Using RSpec
Posted on 5 November 2013 by Willem Meints	

So I’ve been going at this Rails things for a few days now and I learned a lot. One of the things I discovered is how you can make developing applications easier in Rails with the help of some test-driven development techniques.

There’s a lot of stuff you can do to test your application. The lazy method would be to invest your time in manually testing your application. There are however plenty of other options that will save you large amounts of time. I’ve tried a few things myself and I learned that there’s really no need to manually test your rails applications. 99% of all test work can be done fully automated.

In this post I will take you through one of the options and how you can use it to test various aspects of the application. I will also point you to some sources to learn more about the tools.
Building unit tests using RSpec

When you talk about building automated tests to a developer he will think unit tests. Which is probably right for him, since those are the kind of tests usually made by developers. Unit tests are also the first and cheapest line of defense against bugs and general trouble in your software.

Rails has a default testing framework called Unit, but don’t use that. I always delete the test folder in my project containing the Unit based tests.

The reason I don’t like Unit is because it’s way too technical in nature. It’s comparable to NUnit, MSTest, JUnit and all those other frameworks that let you write test methods without any good structure.

A way better alternative is RSpec. The RSpec framework uses a syntax that describes what a class should be doing. It makes for a far better reading experience and is closer to what your product owner would give you as the specification for the software. Below is a short example of an RSpec test:
1	describe Post do
2	  it "validates presence of title" do
3	    post = Post.new(:body => "Test", :tags => [".NET","C#"])
4	    post.valid?.should be_false
5	  end
6	end

The test tells the API that this test describes the Post class. It describes that Post should validate the presence of a title attribute value.

The cool thing about this is that RSpec is able to document all your tests as well as run them.
How to install RSpec

To get RSpec running in your project, you need to download the RSpec-Rails gem. This gem contains everything you need to get going with RSpec tests. To install the gem, add the following line to your project
1	group :test do
2	  gem 'rspec-rails'
3	end

Save the file and run `bundle install` to update the gem configuration. After you have run the bundle command you need to generate some configuration files by running the following command in the terminal.
1	rails generate rspec:install

This will generate the necessary configuration to start building RSpec tests in your project.
Writing RSpec tests

Writing RSpec tests is done by creating new ruby files inside the spec folder of your rails project.

For a rails project, the structure of the spec folder looks a bit like this:

    controllers
    models
    helpers

There’s a different folder for each type of component that is tested in the application.

So to write a test for a Post model, you add a new ruby file with the name post_spec.rb in the spec/models folder.

In this file you then specify your test with describe and it method calls like this:
1	describe [Class] do
2	  it "[Some fact]" do
3	    [Code to execute the example]
4	  end
5	end

You can nest the describe statements to make categories and subcategories in your tests or examples as the makers of RSpec call them.

The subcategories aren’t all that important for smaller components in your application. But once you start testing controllers you will quickly discover that you will need the extra describe calls to keep the examples manageable. Let me demonstrate with a short hypothetical example:
1	describe PostsController do
2	  describe 'GET index' do
3	    it 'should return success for authenticated users' do
4	    # ...
5	    end
6	    it 'should redirect to sign_in for unauthenticated users' do
7	    # ...
8	    end
9	    it 'should load all posts' do
10	      get 'index'
11	      assigns(:posts).should be_true
12	    end
13	  end
14	  describe 'GET new' do
15	    # ...
16	  end
17	end

This set of examples describes the functionality of a single controller. As controllers are more complex you will need to provide more facts about each individual action on the controller. To keep this manageable you will need an extra describe call to keep all the facts for a single operation together.
Verifying results

RSpec contains a large set of verification options that you can use to check the outcome of methods you invoke on your components. As with a lot of things in ruby, you have them available as bonus methods on your own components :-)

For example, I can validate that something is true by invoking this:

post.valid?.should be_true

The first two keywords belong to my object. I’m calling the valid? method on my post object. The next method I’m invoking is an expectation provided by RSpec. This allows me to check the result returned by the valid? method using one of the matchers provided by RSpec.

A matcher is comparable to an assert in .NET and Java in that it compares an expected value against an actual value. In this case, the return value of valid? should be true. This however isn’t the only matcher that’s available. Here’s a very short list of a number of matchers that you can use

    eq – Matches the value exactly against another value
    be_false – Checks that the value is falsy (Remember javascript, yes, this is where that came from!)
    be_true – Checks that the value is truthy
    be([value]) – Checks that the object identities match between the actual and expected value
    match(/[expression]/) – Uses regex to match the actual value against a pattern

And there’s a lot more you can use. To find out more, check out the documentation on matchers: https://www.relishapp.com/rspec/rspec-expectations/docs/built-in-matchers

The should technique isn’t the only way to check the outcome of an operation. There’s also expect. The following example demonstrates this:
1	expect(post.valid?).to be_true
2	expect { post.save }.to raise_error

The first call to the expect method executes the single method call and returns it value to validate using a matcher. The second call does the same thing, but differently. The thing to keep in mind here is that the second expect catches any errors raised in the code block that is being invoked. So if you want to check that a method does raise an error, you need to use the expect with the curly braces.
Specific test considerations

Although you can write any test with the information in the previous two sections, I’m going to add a little more to that information. Because RSpec will offer additional help when you write examples or tests for a Rails application.

For example, if you add an example file to the spec/controllers you will automatically get support for invoking actions on controllers using the HTTP verbs that you’d normally use in the browser. In fact, each of the examples you write assumes that you will write an example for a single HTTP request to your controller. Within each example you can use get,put,delete,post,patch or any of the other HTTP verbs to invoke the controller and then check the results of the operation. For example, the following is possible in a spec that is placed inside the spec/controllers folder:
1	describe PostsController do
2	  describe 'GET index' do
3	    it 'Returns success' do
4	      get 'index'                # Invoke the action on the controller using the GET verb
5	      response.should be_success # Validate the response status
6	    end
7	     
8	    it 'Assigns the posts collection' do
9	      # Create some sample data
10	      post = Post.create(:title => "Test post", :body => "Test post")
11	       
12	      get 'index'                      # Invoke the action on the controller using the GET verb
13	      assigns(:posts).should eq [post] # Make sure that the post we created is loaded
14	    end
15	  end
16	end

The specification is a basic RSpec example set, with an extra subcategory for the index action. Within the first example you see a call to get the index action. This get call can only be done inside a controller example. It uses the rails framework to invoke the index action (Without loading the view for the page!).

After you’ve invoked an action you have two options to validate the results. The first verification you can do is to check the response object. This is the HTTP response returned by the controller and contains the status as well as the template that is going to be rendered by the controller. The second verification you can perform is checking what value the assigned variables are after a controller action is executed. This is done by calling the assigns method with the name of the variable that is going to be assigned. You can save the assigned value to a new variable or check it immediately using the expectations offered by RSpec.

Controller examples are probably the most complex examples you can create with RSpec. When you look at model tests, there’s a lot less going on:
1	describe Post do
2	  it 'validates the presence of title' do
3	    post = Post.create(:body => 'Test post', :tags => ['C#','.NET'])
4	    post.valid?.should be_false
5	  end
6	end

Model classes have no special actions, expectations or matches available to them. These tests are more like unit-tests, which is a lot simpler.
About that database

All Rails applications use some sort of database. This means that your tests will mess up the data in your application’s database. You could try and stub the database, but it’s not recommendable, as that means you have to do a lot of work. There’s an easier and better option called `database_cleaner`

To install the gem, modify your gemfile to look like this:
1	group :test do
2	  gem 'rspec-rails'
3	  gem 'database_cleaner'
4	end

Run `bundle install` again to set up the new gem in your project. After you’ve install the gem you can then configure your RSpec to use database_cleaner by adding the following lines to the `RSpec.configure` block in your spec_helper.rb file inside the spec folder.
1	config.before(:suite) do
2	  DatabaseCleaner.clean_with(:truncation)
3	end
4	 
5	config.before(:each) do
6	  DatabaseCleaner.strategy = :transaction
7	end
8	 
9	config.before(:each, :js => true) do
10	  DatabaseCleaner.strategy = :truncation
11	end
12	 
13	config.before(:each) do
14	  DatabaseCleaner.start
15	end
16	 
17	config.after(:each) do
18	  DatabaseCleaner.clean
19	end

This will clear the database before each test suite (A single .rb file) by truncating everything out of the database. Before each individual example, the data is restored by rolling back a transaction.

By using a transaction per example you get a fast recovery of the database before executing the next example. If you would use this strategy for a full suite however, you will run into timing problems and memory problems as the transaction could grow out of hand over time as you add more examples. Also, by using the combination of truncation and transactions you can set up data at the start of a suite and keep it until that suite is done. This makes writing tests a lot easier when you need more data.

Adding the lines above to the spec helper is all that you need to do to keep a clean database during your tests.
Running tests

Once you’ve written a number of examples/tests and set up your database cleaner gem, you can execute the RSpec tests by executing the following command on the terminal:
1	bundle exec rspec

This will execute all the examples in your project. If you want to execute a subset, you can specify which files to run by appending the name of the folder to the command like this:
1	bundle exec rspec spec/models

Pro tip(tm): Keep in mind that running tests is always done in the test environment. This means that if you haven’t updated your database in the test environment configuration, you will need to do so by executing the following on the terminal:
1	rake db:migrate RAILS_ENV=test
Integration with Guard

RSpec is really useful for testing stuff on model and controller level in your application. This means that you can use RSpec both for unit tests and integration tests.

In my previous post I showed you how to use Guard to automate some of the command line stuff in your rails project. RSpec can be automated using Guard as well. To use this, add the following to your gemfile:

group :development do
gem ‘guard-rspec’
end

Run `bundle install` and execute the following command on the terminal to configure the RSpec plugin for Guard:
1	bundle exec guard init rspec

After executing this command you will have additional configuration in your Guardfile to run the RSpec examples when a controller or model is changed. Restart Guard to load the new specification and start running examples as you change your code.
What’s next?

With the RSpec tests up and running, I’m going to build some more bits of my application. So it will take a few days to generate some new material :-) Keep an eye out for the next part!

In the mean time, read this book: The RSpec book
It contains a ton of useful information on how to build proper examples with RSpec and what’s going on behind the scenes.
This entry was posted in Various by Willem Meints. Bookmark the permalink.
Willem Meints	
About Willem Meints
Developing mobile apps, Silverlight expert. 100% Web 2.01 proof and CSS 3.x compatible. And all that as a human being.
View all posts by Willem Meints →	


===========================================================
.[]
===========================================================
.[]

===========================================================
.[]EXAMPLES
==========================================================
55.[]Ex. of Rspec with context for a data class, user model ; X.awesomebits/spec/models/user_spec.rb at master · awesomefoundation/awesomebits
https://github.com/awesomefoundation/awesomebits/blob/master/spec/models/user_spec.rb
awesomebits/spec/models/user_spec.rb at master · awesomefoundation/awesomebits
require 'spec_helper'

describe User do
  it { should validate_presence_of(:first_name) }
  it { should validate_presence_of(:last_name) }
  it { should validate_presence_of(:encrypted_password) }
  it { should have_many(:roles) }
  it { should have_many(:chapters).through(:roles) }
  it { should have_many(:votes) }
  it { should have_many(:projects).through(:votes) }

  context "#trustee?" do
    let(:user){ build(:user) }
    let(:chapter){ build(:chapter) }
    let(:role){ build(:role, :user => user, :chapter => chapter) }
    before do
      user.roles = [role]
    end

    it 'returns true if the user is a trustee anywhere' do
      user.trustee?.should be_true
    end

    it 'returns false if the user is not a trustee anywhere' do
      user.roles = []
      user.trustee?.should be_false
    end

    it 'returns true if the user is only a dean somewhere' do
      role.name = "dean"
      user.trustee?.should be_true
    end

    it 'returns true if the user is an admin' do
      user.admin = true
      user.roles = []
      user.trustee?.should be_true
    end
  end

  context '#can_invite?' do
    let(:user) { build(:user) }
    it 'returns true if the user is an admin' do
      user.admin = true
      user.can_invite?.should be_true
    end
    it 'asks the roles if it can invite if not an admin' do
      user.admin = false
      user.roles.stubs(:can_invite?)
      user.can_invite?
      user.roles.should have_received(:can_invite?)
    end
  end

  context '#can_invite_to_chapter?' do
    let(:user) { build(:user) }
    it 'returns true if the user is an admin' do
      user.admin = true
      user.can_invite_to_chapter?(:chapter).should be_true
    end
    it 'asks the roles if it can invite if not an admin' do
      user.admin = false
      user.roles.stubs(:can_invite_to_chapter?)
      user.can_invite_to_chapter?(:chapter)
      user.roles.should have_received(:can_invite_to_chapter?)
    end
  end

  context "#can_manage_chapter?" do
    let(:user) { build(:user) }
    it 'returns true if the user is an admin' do
      user.admin = true
      user.can_manage_chapter?(:chapter).should be_true
    end
    it 'asks the roles if it can manage if not an admin' do
      user.admin = false
      user.roles.stubs(:can_manage_chapter?)
      user.can_manage_chapter?(:chapter)
      user.roles.should have_received(:can_manage_chapter?)
    end
  end

  context "#can_manage_users?" do
    let(:user) { build(:user) }
    it 'returns true if the user is an admin' do
      user.admin = true
      user.can_manage_chapter?(:chapter).should be_true
    end
    it 'asks the roles if it can manage if not an admin' do
      user.admin = false
      user.roles.stubs(:can_manage_users?)
      user.can_manage_users?(:chapter)
      user.roles.should have_received(:can_manage_users?)
    end
  end

  context "#can_view_finalists_for?" do
    let(:user) { build(:user) }
    it 'returns true if the user is an admin' do
      user.admin = true
      user.can_view_finalists_for?(:chapter).should be_true
    end
    it 'asks the roles if it can view finalists if not an admin' do
      user.admin = false
      user.roles.stubs(:can_view_finalists_for?)
      user.can_view_finalists_for?(:chapter)
      user.roles.should have_received(:can_view_finalists_for?)
    end
  end

  context "#can_edit_project?" do
    let(:user) { build(:user) }
    it 'returns true if the user is an admin' do
      user.admin = true
      user.can_edit_project?(:chapter).should be_true
    end
    it 'asks the roles if it can view finalists if not an admin' do
      user.admin = false
      user.roles.stubs(:can_edit_project?)
      user.can_edit_project?(:chapter)
      user.roles.should have_received(:can_edit_project?)
    end
  end

  context "#can_edit_all_profiles?" do
    let(:user) { build(:user) }
    it 'returns true if the user is an admin' do
      user.admin = true
      user.can_edit_all_profiles?.should be_true
    end
    it 'returns false if the user is not an admin' do
      user.admin = false
      user.can_edit_all_profiles?.should be_false
    end
  end

  context "#can_mark_winner?" do
    let(:user) { build(:user) }
    let(:project) { stub }
    it 'returns true if the user is an admin' do
      project.stubs(:in_any_chapter?).returns(false)
      user.admin = true
      user.can_mark_winner?(project).should be_true
    end
    it 'asks the roles if it can manage if not an admin' do
      project.stubs(:in_any_chapter?).returns(false)
      user.admin = false
      user.roles.stubs(:can_mark_winner?)
      user.can_mark_winner?(project)
      user.roles.should have_received(:can_mark_winner?)
    end
    it 'returns true if the project is in the Any chapter' do
      project.stubs(:in_any_chapter?).returns(true)
      user.admin = false
      user.can_mark_winner?(project)
    end
  end

  context ".deans_first" do
    let(:chapter){ create(:chapter) }
    let!(:trustee){ create(:role, :chapter => chapter) }
    let!(:dean){ create(:role, :name => "dean", :chapter => chapter) }
    it 'orders the users so deans are first' do
      chapter.users.deans_first.should == [dean.user, trustee.user]
    end
  end

  context ".including_role" do
    let(:chapter){ create(:chapter) }
    let!(:trustee){ create(:role, :chapter => chapter) }
    let!(:dean){ create(:role, :name => "dean", :chapter => chapter) }
    it 'includes the role name on the records' do
      User.including_role.where(:id => dean.user.id).first.role.should == "dean"
      User.including_role.where(:id => trustee.user.id).first.role.should == "trustee"
    end
  end

  context ".all_with_chapter" do
    let!(:chapter) { create(:chapter) }
    let!(:trustee) { create(:user) }
    let!(:role) { create(:role, :user => trustee, :chapter => chapter) }
    let!(:admin) { create(:user) }
    it 'includes all users' do
      User.all_with_chapter(nil).should == [trustee, admin]
    end
    it 'includes only trustees for chapter' do
      User.all_with_chapter(chapter.id).should == [trustee]
    end
  end

end

==========================================================
56.[]Ex. of Rspec with context for a non-data class, user controller  ; X.awesomebits/spec/controllers/users_controller_spec.rb at master · awesomefoundation/awesomebits
https://github.com/awesomefoundation/awesomebits/blob/master/spec/controllers/users_controller_spec.rb
awesomebits/spec/controllers/users_controller_spec.rb at master · awesomefoundation/awesomebits
require 'spec_helper'

describe UsersController do
  context "signed in as admin user" do
    let(:user) { create(:user, :admin => true) }
    before do
      sign_in_as user
      get :index
    end
    it { should respond_with(:success) }
  end
  context "signed in as non-admin user" do
    let(:role) { create(:role) }
    let(:user) { role.user }
    let(:chapter) { role.chapter }
    before do
      sign_in_as user
      get :index
    end
    it { should redirect_to(chapter_users_path(chapter)) }
  end
  context "signed out" do
    before do
      sign_out
      get :index
    end
    it { should redirect_to(root_url) }
  end
end
